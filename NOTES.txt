DEPENDENCIES

 - C/C++
 - GNU Make


BUILDING

To build all binaries, simply run make:

% make -j4

Output files are in output/

To build just debug/release binaries:

% make debug  # or release

To create the combined player source file at output/player-combined.cc:

% make combined

To only build e.g. a release build of the solver:

% make -f Makefile.release solver


STRATEGY

Let's call the digits that were already placed in the grid the *givens*, or more
accurately: the givens are nonconflicting (cell, digit) pairs.

For a set of givens, we can (sometimes) enumerate all possible solutions in the
grid. Assume we have a full set of solutions.

Let's call the candidates of a cell the set of digits that occurs in that cell
in some solution. That means our move should chose exactly one candidate to fill
in.

Let's distinguish between cells with a single candidate (I call those
*inferred digits/cells* because the digit is fixed but not yet filled in), and
multiple candidates (I call those *choice cells* because if I fill in this cell
I have to make a choice which candidate to use). I call the set of inferred
cell/digit pairs F with size |F|.

Now we want to determine if the current state is winning or losing, and (if
winning) what a winning move is.

If |F| is even, then the value of the state is the same as the state in which
all the inferred cells have been filled in.

Proof: let's call the states S and T0 respectively. If I have a winning strategy
in T0, I can infer a winning strategy in S by playing according to the winning
stategy in T0, except that whenever my opponent makes a move in F, I respond with
a move in F too. Eventually F is empty (if I don't win earlier).

Conversely, if I don't have a winning strategy in T, I can either keep making
losing moves in T, or make a move in F which my opponent can counter.

This means that whenever |F| is even we can solve the problem recursively, and
pick an arbitrary move that leads to a state that is losing for the opponent.

When |F| is odd the situation is more interesting. My initial thought was that
filling in one digit would invert the grid value. But that's not the case! (See
tools/check-parity-assumption.py for some tests and a few more details.)

It does turn out that only the parity of |F| matters.

The general player algorithm works as follows:

  1. Calculate all solutions (if this is not possible, abort and move randomly).
  2. Identify inferred cells (F) and choice cells (C).
  3. Search for immediately winning solutions; if there is one, return it.
  4. If not, recursively solve C:
      - If |F| is odd, try filling in an inferred digit and solving the
        resulting grid. If the resulting grid is losing, report a win.
      - Otherwise, try filling in one of the choice cells C, and for each
        chosen cell and digit, go to step 2. If the grid is losing, report
        a win.

The hard parts of the algorithms are 1 (EnumerateSolutions() in state.cc) and
4 (DetermineWinningMove() in analysis.cc).


STATISTICS

I did some profiling of analysis.cc and found the following stats on the number
of solutions (solutions.size()) that are passed to SortByDigitAtPosition()
called from IsWinning2() in analysis.cc, on this state:
......3.....3...........6..6...39..5.9.264.8.43.8.57..8....2......1..89..4..5..1.

 - Minimum:         4
 - Median (50%):   25
 - Average:        34
 - 99%:           154
 - Maximum:      1583

This shows solution sets are skewed towards relatively small sizes, and the
sorting algorithm should be optimized for those cases. Note however that sorting
time is also proportional to size: i.e. the 1% largest sets probably take more
than 1% of the time!


OPEN QUESTIONS

Can we meaningfully decompose the game?

At first glance, it seems like we can identify independent parts of the grid
and solve them independently.

For example, if we have only the top-left box with the following candidates:

    [123] [123] [123]   4  5  6   7  8  9
    [456] [456] [456]   7  8  9   1  2  3
    [78]  [78]    9     1  2  3   4  5  6

Then the puzzle can be decomposed into 3 parts (the rows of the box) which
are solved independently.

There are two problems:

  1. This doesn't account for the existence of inferred digits, which ruin the
     Sprague-Grundy theorem.
  2. It doesn't seem to happen very often in practice that parts of the grid
     are independent (at least not early in the game, when a solver would
     benefit the most from this kind of deomposition).


CAIA NOTES

  - Server sometimes sends empty lines (has this been fixed?)
    https://forum.codecup.nl/read.php?31,2221
  - Best guess as to what the sample players do:
      - player1 plays a random valid move, but never claims a win.
      - player2 plays a random valid move, and also claims a win if the solution
        is unique at the start of its turn ("!") or after its move ("Xx0!")
      - player3 plays a winning move if there is one, otherwise plays randomly.


CODECUP SERVER NOTES

  - 64 bit
  - GCC 11.3.0 (release date: April 21, 2022)
  - referee does NOT send Quit after I send my winning move. So I cannot
    write statistics to stderr before exiting; I have to do it before my last
    move.
  - Speed: initial analysis suggests the Codecup CPU
    (Intel(R) Xeon(R) CPU E5-2620 0 @ 2.00GHz) is half the speed of my laptop
    (Intel(R) Core(TM) i7-7560U CPU @ 2.40GHz), which kind of makes sense since
    my laptop CPU supports bursts up to 3.80 GHz.


RELEASE INSTRUCTIONS

  1. `git status` # Make sure all changes are commited!
  2. `make clean`, `make all -j4`, `make combined`
  3. Use arbiter.py to run a competition with the new and previous players
  4. Check player logs for unexpected warnings/errors.
  5. Submit to CodeCup.
  6. `git tag submission-#-id-#`
  7. Make a backup: `cp -r output/ backups/$(git rev-parse --short HEAD)`
